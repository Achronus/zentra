{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Zentra","text":"<p> Zentra, your all in one Python SDK for building FastAPI [] and Next.js [] applications. </p> <p>Docs</p> <p>Code</p> <p>Every new software project brings a familiar set of repetitive tasks: configuring API routes, setting up authentication, and crafting frontend components from scratch. These repetitive steps not only drain your time but also divert your focus from building the unique features that set your application apart.</p> <p>What if you have 10 projects to build, or 100, or 1000? Imagine having to set up everything from scratch every single time. The constant cycle of boilerplate coding can be frustrating and counterproductive, leaving you bogged down in setup rather than innovating.</p> <p>Introducing Zentra \u2014 an open-source, free to use, SDK for rapidly creating FastAPI [] and Next.js [] applications.</p> <p>Packed with an intuitive suite of CLI commands, documentation, and development kit, this tool simplifies your development process, allowing you to effortlessly build applications in weeks, not months.</p> <ul> <li> <p> Getting Started</p> <p>What are you waiting for?!</p> <p> Get Started</p> </li> <li> <p> Open Source, MIT</p> <p>All Zentra packages are licensed under the MIT License.</p> <p> License</p> </li> </ul>"},{"location":"#active-development","title":"Active Development","text":"<p>Zentra is a tool that is continuously being developed. There's a lot still to do to make it a fully functioning SDK, such as a working CLI, detailed API documentation, and components for various libraries.</p> <p>Our goal is to provide a quality open-source product that works 'out-of-the-box' that everyone can experiment with, and then gradually fix unexpected bugs and introduce more component libraries on the road to a <code>v1.0.0</code> release.</p>"},{"location":"#support","title":"Support","text":"<p>We'll need help from developers like YOU  to make this tool a delight to use, and a product worthy of the <code>Python</code>, <code>NextJS</code>, <code>React</code> and <code>Software/Web Development</code> community.</p> <p>Feedback and criticism will always be welcomed, and is encouraged to help make this tool worthwhile.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>To view version changes for a Zentra package, check the GitHub links below.</p> <ul> <li>Zentra SDK []</li> <li>Zentra API []</li> </ul>"},{"location":"api/","title":"Zentra API","text":"<p>Docs</p> <p>Code</p> <p>PyPi</p> <p>Zentra API is a powerful tool for building FastAPI [] applications. </p> <p>It comes packed with it's own CLI tool and library that encourages rapid development and clean, pragmatic API design.</p>"},{"location":"api/#whats-included","title":"What's Included?","text":"<p>When creating a project with <code>zentra-api</code> you immediately get access to the following:</p> <ul> <li>Built-in user authentication with JWT token protection</li> <li>Preconfigured CORs middleware</li> <li>A SQLite [] database configured with Alembic [] and SQLAlchemy []</li> <li>Built-in templated route responses following best practices</li> <li>A simple folder structure to make project navigation a breeze</li> <li>Prebuilt Pytests [] so you can focus on your own code  </li> <li>And, access to our package filled with other goodies</li> </ul> <p>But that's not all! We've also got plans to add:</p> <ul> <li>Rate limiting with SlowAPI []</li> <li>API key configuration</li> <li>An admin interface for easily navigating your database</li> <li>Email based password recovery</li> <li>A <code>build</code> command to go from development to production in minutes</li> <li>And so much more...</li> </ul>"},{"location":"api/#getting-started","title":"Getting Started","text":"<p>To get started, install the <code>zentra-api</code> package with Poetry [] through PIP []:</p> <pre><code>pip install zentra-api poetry\n</code></pre> <p>Next, click the button below to move onto our User Guide to learn how to get started with Zentra API.</p>"},{"location":"api/poetry-scripts/","title":"Poetry Scripts","text":"<p>Poetry scripts are a way to create extra CLI commands inside Poetry projects. These are specifically designed for quickly executing small chunks of code with minimal effort.</p> <p>Every new API project is preconfigured with a few unique ones stored inside the <code>pyproject.toml</code> file under <code>poetry.scripts</code>. </p> <p>These are directly connected to the <code>scripts</code> folder and only work when you have installed the your newly built project using the <code>install poetry</code> command. </p> <p>You can read more about this in the First Steps tutorial.</p> pyproject.tomlRelated Files <pre><code>...\n[tool.poetry.scripts]\nrun-dev = \"scripts.run:development\"\nrun-prod = \"scripts.run:production\"\ndb-migrate = \"scripts.db_migrate:main\"\n...\n</code></pre> <pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 migrations/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 db_migration.py\n\u2502   \u2514\u2500\u2500 run.py\n\u251c\u2500\u2500 tests/\n\u2502    \u2514\u2500\u2500 ...\n...\n</code></pre> <p>So far, we've introduced 3 scripts to simplify specific operations.</p>"},{"location":"api/poetry-scripts/#1-run-dev","title":"1. run-dev","text":"<p><code>run-dev</code> allows you to quickly run the FastAPI [] development server on host <code>127.0.0.1:8080</code>. </p> <p>It's equivalent to this command:</p> <pre><code>fastapi dev app/main.py --port 8080\n</code></pre> <p>You'll often find yourself turning the development server on and off and repeating the full command can be very tedious. Well, now you don't have to worry about it!</p>"},{"location":"api/poetry-scripts/#2-run-prod","title":"2. run-prod","text":"<p>A compliment to <code>run-dev</code>, <code>run-prod</code> allows you to quickly run the FastAPI [] production server on host <code>0.0.0.0:8080</code>.</p> <p>It's equivalent to this command:</p> <pre><code>uvicorn app.main:app --host 0.0.0.0 --port 8080\n</code></pre> <p>It's a great way to quickly spin-up your production server to test how your API performs in production, and to run the production environment in Docker [] containers. </p>"},{"location":"api/poetry-scripts/#3-db-migrate","title":"3. db-migrate","text":"<p><code>db-migrate</code> is a faster way to make Alembic [] database migrations. </p> <p>Normally, you'd need to run two commands to make a single migration:</p> <pre><code>alembic revision --autogenerate -m \"&lt;description&gt;\"\nalembic upgrade head\n</code></pre> <p>We wanted to simplify this process by compressing migrations into a single command. Now, all you need to do is run the following:</p> <pre><code>db-migrate \"&lt;description&gt;\"\n</code></pre> <p>The <code>description</code> explains what the database migration does. So for example, create posts table or update user table. You can read more about migrations in the Alembic [] documentation.</p> <p>When running the command, you'll be <code>prompted</code> to update the <code>head</code>. We can skip this prompt using the <code>--force</code> flag like so:</p> <pre><code>db-migrate \"&lt;description&gt;\" --force\n</code></pre> <p>This command has been a huge asset for improving our workflow and we hope you enjoy using it as much as we do!</p>"},{"location":"api/route-responses/","title":"Route Responses","text":"<p>Coming Soon</p>"},{"location":"api/commands/","title":"CLI Commands","text":"<p>This section focuses on the command line interface (CLI) commands you can use with the <code>zentra-api</code> package.</p> <p>Like the tutorial series, we've divided this section into separate pages to make things easier to navigate. You can access the commands using the navigation menu on the left or select a command from the list below.</p> <p>Help Flag</p> <p>All commands are configured with a <code>--help</code> flag that provides you with extra information about them. Simply add it to the command to read more information about it. For example:</p> <pre><code>zentra-api init --help\n</code></pre>"},{"location":"api/commands/#available-commands","title":"Available Commands","text":"<ul> <li>init</li> <li>add-route</li> <li>new-key</li> <li>build</li> </ul>"},{"location":"api/commands/add-route/","title":"Add Route","text":""},{"location":"api/commands/build/","title":"Build","text":""},{"location":"api/commands/init/","title":"Init","text":"Noteworthy Features <ul> <li>First use: configures the directory as a <code>FastAPI</code> project</li> <li>Additional uses: adds missing files to the directory</li> </ul> <p>This command creates a <code>FastAPI</code> project in a specific directory based on a given <code>&lt;project_name&gt;</code>.</p> <pre><code>zentra-api init &lt;project_name&gt;\n</code></pre> <p>The <code>project_name</code> must be a string that is at least 2 characters long.</p>"},{"location":"api/commands/init/#optional-flags","title":"Optional Flags","text":"Flag Description <code>--hide-output</code> Suppresses the console output, hiding it from view. <p>You can read more about this command in our First Steps Tutorial.</p>"},{"location":"api/commands/new-key/","title":"New Key","text":"Noteworthy Features <ul> <li>Every use: generates a new secret key.</li> </ul> <p>This command creates a new randomly generated URL-safe token<sup>1</sup> using Base64 encoding.</p> <pre><code>new-key\n</code></pre>"},{"location":"api/commands/new-key/#optional-parameters","title":"Optional Parameters","text":"Parameter Type Description Default <code>size</code> Integer The number of bytes to generate. Each byte is approximately 1.3 characters. 32 <ol> <li> <p>A URL-safe token is a string safe for use in URLs by avoiding characters that might require special encoding such as <code>+</code>, <code>/</code>, or <code>=</code>.\u00a0\u21a9</p> </li> </ol>"},{"location":"api/lib/","title":"API Reference","text":"<p>Zentra API comes packed with its own helper methods and classes to really push your development game to the next level.</p> <p>You've already seen a few of these in the Authentication tutorial, but that's not all it has to offer!</p> <p>In this section we focus solely on the extra functionality that the Zentra API package has to offer. </p>"},{"location":"api/lib/auth/","title":"zentra_api.auth","text":"<p>Coming Soon</p>"},{"location":"api/lib/core/","title":"zentra_api.core","text":"<p>Coming Soon</p>"},{"location":"api/lib/crud/","title":"zentra_api.crud","text":"<p>Coming Soon</p>"},{"location":"api/lib/responses/","title":"zentra_api.responses","text":"<p>Coming Soon</p>"},{"location":"api/lib/schema/","title":"zentra_api.schema","text":"<p>Coming Soon</p>"},{"location":"api/tutorial/","title":"Tutorial - User Guide","text":"<p>This tutorial series shows you how to use <code>zentra-api</code> with most of its features, step by step. </p> <p>Each section gradually builds on the previous ones, but is structured into separate topics, so that you can directly navigate to any topic you need!</p> <p>When your ready, click on the button below to start your first steps! \ud83e\udd29</p>"},{"location":"api/tutorial/authentication/","title":"User Authentication","text":"<p>Now let's discuss something integral to almost every project: user authentication. </p> <p>I can't tell you how many hours we've spent thinking about this topic, mulling over what frameworks to use, how to integrate it with our databases, etc. Talk about boring! \ud83d\ude34</p> <p>Thankfully, FastAPI [] makes it extremely easy, and with Zentra it's straight out of the box! \ud83d\ude0d</p> <p>We abstract a lot of the details away using the <code>zentra_api</code> package to keep things simple for you, but still give you the freedom to configure authentication how you want!</p> <p>Our authentication files live in the <code>app/auth</code> directory, shown below. </p> Authentication Directory<pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 responses.py\n\u2502   \u2502   \u2514\u2500\u2500 schema.py\n\u2502   \u251c\u2500\u2500 ...\n...\n</code></pre> <p>You may have noticed that the folder follows the exact same file structure as the routes we created in the Creating Routes tutorial. We've done this deliberately!</p> <p>The <code>auth</code> directory is just another set of API routes but separated for convenience. </p> <p>Auth Reset</p> <p>Don't like how we've done things? Just delete the folder and start fresh! Don't worry, we won't be offended! \ud83d\ude09</p> <p>Warning</p> <p>Technically, there is a little more you should remove when getting rid of the <code>auth</code> routes, such as the configuration settings and the database models \ud83d\ude05, but simply removing the folder is good enough to disable the routes. </p> <p>We plan to add a <code>--no-auth</code> flag in a future version that will do all of this for you, but 9 times out of 10 you'll need authentication anyway! \ud83d\ude01</p> <p>The main thing you need to know here is how the routes work, rather than the underlying functionality. Feel free to explore the code yourself! It's an extension of the FastAPI [] security tutorial with refresh tokens and a bit of Zentra flair \ud83d\ude09.</p> <p>Okay, now let's check out our routes!</p>"},{"location":"api/tutorial/authentication/#routes","title":"Routes","text":"<p>Note</p> <p>All authentication routes start with <code>api/auth/</code>. This simple naming convention keeps our API consistent and easy to use.</p> <p>We follow the same pattern with our token routes - <code>api/auth/token</code>.</p> <p>Zentra API has five starting authentication routes:</p> <ol> <li><code>/api/auth/users/me</code> - retrieves the user's own details, if they are authenticated.</li> <li><code>/api/auth/register</code> - creates a user in the database given a <code>username</code> and <code>password</code>.</li> <li><code>/api/auth/token</code> - provides an access token for the user, if their login details are correct</li> <li><code>/api/auth/token/verify/{token}</code> - verifies that an access token is valid (e.g., hasn't expired yet)</li> <li><code>/api/auth/token/refresh</code> - creates a new access token from the refresh token </li> </ol>"},{"location":"api/tutorial/authentication/#get-user","title":"Get User","text":"Route <p><code>/api/auth/users/me</code></p> <p>So we know this route get's the user's details, but what details? Well, this depends on two factors:</p> <ol> <li>What user information you are storing in the database</li> <li>What information the <code>GetUser</code> response model has access to</li> </ol> <p>By default, we use two separate database tables for our users: </p> <ol> <li><code>DBUserDetails</code> for personal information, and</li> <li><code>DBUser</code> for login credentials </li> </ol> <p>We've found this to be effective for both performance and security, especially when storing a lot of personal information. </p> <p>Here's our tables:</p> db_models/user.py<pre><code>from sqlalchemy import Boolean, Column, ForeignKey, Integer, String\n\nfrom app.core.db import Base\n\n\nclass DBUser(Base):\n    \"\"\"A model of the `User` table.\"\"\"\n\n    __tablename__ = \"users\"\n\n    id = Column(Integer, primary_key=True)\n    username = Column(String, unique=True, index=True)\n    password = Column(String)\n    is_active = Column(Boolean, default=True)\n\n\nclass DBUserDetails(Base):\n    \"\"\"A model of the `UserDetails` table.\"\"\"\n\n    __tablename__ = \"user_details\"\n\n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    email = Column(String, unique=True, default=None)\n    phone = Column(String, unique=True, default=None)\n    full_name = Column(String, default=None)\n</code></pre> <p>Notice how we only capture three main details here: the user's <code>full_name</code>, <code>email</code>, and <code>phone</code> number. Feel free to update this as needed! \ud83d\ude01</p> <p>So, what about our <code>GetUser</code> response model? Using a bit of Pydantic [] \u2728 (courtesy of FastAPI) and Python class inheritance, we combine the <code>UserBase</code> with the <code>UserDetails</code> model.</p> auth/schema.py<pre><code>from pydantic import BaseModel, Field\n\n\nclass UserBase(BaseModel):\n    username: str = Field(..., description=\"A unique username to identify the user\")\n\n\nclass CreateUser(UserBase):\n    password: str = Field(\n        ..., description=\"The users password to login to the platform\"\n    )\n    is_active: bool = Field(default=True, description=\"The users account status\")\n\n\nclass UserDetails(BaseModel):\n    email: str | None = Field(default=None, description=\"The users email address\")\n    phone: str | None = Field(default=None, description=\"The users contact number\")\n    full_name: str | None = Field(default=None, description=\"The users full name\")\n    is_active: bool = Field(..., description=\"The users account status\")\n\n\nclass GetUser(UserBase, UserDetails):\n    pass\n</code></pre> <p>So our data could look like this:</p> Example Data JSON<pre><code>{\n    \"email\": \"johndoe@email.com\",\n    \"phone\": \"+44123456789\",\n    \"full_name\": \"Agent 47\",\n    \"is_active\": true,\n    \"username\": \"agent47\",\n}\n</code></pre> <p>Great! That's simple enough, but should we really only be sending this information through our route? It's not very informative. Surely, there's a better way?</p> <p>This is where one of Zentra's unique features come in! When passing our response model through a <code>zentra_api.responses.SuccessResponse</code> we get a way more detailed and informative JSON response. </p> <p>For this specific route, here's our responses:</p> 200 Ok400 Bad Request401 Unauthorized <pre><code>{\n    \"status\": \"success\",\n    \"code\": 201,\n    \"response\": \"200_OK\",\n    \"data\": {\n        \"email\": \"johndoe@email.com\",\n        \"phone\": \"+44123456789\",\n        \"full_name\": \"Agent 47\",\n        \"is_active\": true,\n        \"username\": \"agent47\",\n    },\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 400,\n    \"response\": \"400_BAD_REQUEST\",\n    \"message\": \"User already registered.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 401,\n    \"response\": \"401_UNAUTHORIZED\",\n    \"message\": \"Not authenticated.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre> <p>Like \u2728, we now immediately see if the response is successful, what type of response code is passed, we get the same data we needed, and get to see any HTTP headers that were passed with the request. </p> <p>Your API's just got a whole lot funner to work with! \ud83d\ude01</p> <p>Tip</p> <p>You can learn more about how these responses work in our Route Responses page. </p> <p>Onto the next one!</p>"},{"location":"api/tutorial/authentication/#register-user","title":"Register User","text":"Route <p><code>/api/auth/register</code></p> <p>Unlike our previous route, that reads information from the database, this one adds a new user to the <code>DBUser</code> table. </p> <p>Instead of using the <code>GetUser</code> response model, it uses the <code>CreateUser</code> response model.</p> auth/schema.py<pre><code>from pydantic import BaseModel, Field\n\n\nclass UserBase(BaseModel):\n    username: str = Field(..., description=\"A unique username to identify the user\")\n\n\nclass CreateUser(UserBase):\n    password: str = Field(\n        ..., description=\"The users password to login to the platform\"\n    )\n    is_active: bool = Field(default=True, description=\"The users account status\")\n\n\nclass UserDetails(BaseModel):\n    email: str | None = Field(default=None, description=\"The users email address\")\n    phone: str | None = Field(default=None, description=\"The users contact number\")\n    full_name: str | None = Field(default=None, description=\"The users full name\")\n    is_active: bool = Field(..., description=\"The users account status\")\n\n\nclass GetUser(UserBase, UserDetails):\n    pass\n</code></pre> <p>This is pretty self-explanatory. Given three values: <code>username</code>, <code>password</code>, and <code>is_active</code>; we create a new user in the database.</p> <p>Here's an example of the routes responses:</p> 201 Created400 Bad Request <pre><code>{\n    \"status\": \"success\",\n    \"code\": 201,\n    \"response\": \"201_CREATED\",\n    \"data\": {\n        \"username\": \"agent47\"\n    },\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 400,\n    \"response\": \"400_BAD_REQUEST\",\n    \"message\": \"User already registered.\",\n    \"headers\": null\n}\n</code></pre>"},{"location":"api/tutorial/authentication/#login-for-access-token","title":"Login For Access Token","text":"Route <p><code>/api/auth/token</code></p> <p>Next, we have our login route for retrieving an access and refresh token. Access and refresh tokens are JSON Web Tokens (JWTs) that act as a form of authentication to the API. They both have a slightly different purpose. Here's a brief overview:</p> <ul> <li>Access token - allows the user to use the API</li> <li>Refresh token - acts as a user session for a period of time </li> </ul> <p>In our case, we use the <code>HS256</code> algorithm for encryption with a <code>15</code> minute expiry for access tokens and a <code>7</code> day expiry for refresh tokens. They use the <code>AUTH__SECRET_ACCESS_KEY</code> and <code>AUTH__SECRET_REFRESH_KEY</code>, respectively, found in your <code>.env</code> file. </p> Updating Auth Settings <p>We want to provide a solution that works out of the box without overwhelming you with configuration settings, so we deliberately fixed the algorithm and expiry times - it's less things to worry about!</p> <p>However, if you need more flexibility you can tweak these settings using the <code>.env</code> file. Here's an example:</p> .env<pre><code>...\n# Authentication configuration details\nAUTH__SECRET_ACCESS_KEY=c_KnbHr01TI5qjsAZoGLpeZrpdK4u5AOy7RXHFpsMeE # (1)!\nAUTH__SECRET_REFRESH_KEY=M2Myg1Z2vfUNHzIBVcsKhZCcFi6n4knNLv57Gip6a3M\nAUTH__ALGORITHM=\"HS256\" # (2)!\nAUTH__ACCESS_TOKEN_EXPIRE_MINS=15  # (3)!\nAUTH__REFRESH_TOKEN_EXPIRE_MINS=10080  # (4)!\n...\n</code></pre> <ol> <li>The JWT encryption keys. Keep them secret, keep them safe! \ud83e\udd2b </li> <li>The encryption algorithm. Currently, this is limited to three options: <code>['HS256', 'HS384', 'HS512']</code></li> <li>The access token expiration time in minutes</li> <li>The refresh token expiration time in minutes. <code>10080 = 7 days</code>. This always lasts longer than your access token</li> </ol> <p>JWTs are out of the scope of this tutorial, but if you want to learn more, we highly recommend you check out these links from JWT.io [] and Auth0 [].</p> <p>Here's an example of the routes responses:</p> 202 Accepted401 Unauthorized <pre><code>{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0IiwiZXhwIjoxNzI1ODg2MjkwfQ.9nkNDi-_6uel6nUIiAHELrB8j1CqK1h-N7hx2QwRYxw\",\n    \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0IiwiZXhwIjoxNzI2NDkwMTkwfQ.pw5wtaLPq14h0nzbbhSmq-C1qfwYsLsxvNTozzfG4HM\",\n    \"token_type\": \"bearer\"\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 401,\n    \"response\": \"401_UNAUTHORIZED\",\n    \"message\": \"Incorrect username or password.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre>"},{"location":"api/tutorial/authentication/#verify-user-token","title":"Verify User Token","text":"Route <p><code>/api/auth/token/verify/{token}</code></p> <p>This route compliments the previous one and simply verifies that an access token is valid using your <code>AUTH__SECRET_ACCESS_KEY</code> in your <code>.env</code> file. </p> <p>Here's an example of the routes responses:</p> 200 Ok401 Unauthorized <pre><code>{\n    \"status\": \"success\",\n    \"code\": 200,\n    \"response\": \"200_OK\",\n    \"message\": \"Token is valid.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 401,\n    \"response\": \"401_UNAUTHORIZED\",\n    \"message\": \"Not authenticated.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre>"},{"location":"api/tutorial/authentication/#refresh-access-token","title":"Refresh Access Token","text":"Route <p><code>/api/auth/token/refresh</code></p> <p>The last route is another simple one! Given a refresh token it creates a new access token for the user.</p> <p>When working with frontend applications, you'll often find yourself using this route and the token verification one together. After all, when an access token expires, you'll need to refresh it!</p> <p>Here's an example of the routes responses:</p> 201 Created401 Unauthorized <pre><code>{\n    \"access_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0IiwiZXhwIjoxNzI1ODg2MzQzfQ.rQBlpSx6UQgz8U52mSeVqb6-B7Xe8vKUTVO4ghJyaQU\",\n    \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ0ZXN0IiwiZXhwIjoxNzI2NDkwMTkwfQ.pw5wtaLPq14h0nzbbhSmq-C1qfwYsLsxvNTozzfG4HM\",\n    \"token_type\": \"bearer\"\n}\n</code></pre> <pre><code>{\n    \"status\": \"error\",\n    \"code\": 401,\n    \"response\": \"401_UNAUTHORIZED\",\n    \"message\": \"Invalid refresh token.\",\n    \"headers\": {\n        \"WWW-Authenticate\": \"Bearer\"\n    }\n}\n</code></pre>"},{"location":"api/tutorial/authentication/#future-plans","title":"Future Plans","text":"<p>So far our routes focus on JWT tokens and OAuth2 authentication. This is great for most use cases but sometimes you may need something a little more extensive such as Oauth2 scopes, cookies, or API keys. </p> <p>We have plans to integrate these in the future, but ultimately it's up to you to decide what type of authentication you need. Zentra is just an extension on top of FastAPI, so the possibilities are truly endless. \u2728</p> <p>Okay, now that we understand more about our authentication, let's move onto our project settings. See you there! \ud83d\ude01</p>"},{"location":"api/tutorial/create-routes/","title":"Creating Routes","text":"<p>Coming Soon</p> <p>Route creation is next on our list for Zentra API. In the next version, you'll be able to create routes efficiently using the <code>add-route</code> CLI command.</p>"},{"location":"api/tutorial/create-tables/","title":"Creating Database Tables","text":"<p>Coming Soon</p>"},{"location":"api/tutorial/first-steps/","title":"First Steps","text":"<p>Our first step is a simple one: create a new project. </p> <p>Zentra makes this extremely easy and provides a lot of functionality out of the box (What's Included?). </p>"},{"location":"api/tutorial/first-steps/#creating-a-project","title":"Creating a Project","text":"<p>To create a new project we use the <code>init</code> command with a custom <code>&lt;project_name&gt;</code> like so:</p> <pre><code>zentra-api init &lt;project_name&gt;\n</code></pre> <p>After a few seconds, you'll find a new project in your directory with the following file structure:</p> Folder Structure<pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u2514\u2500\u2500 db_models/\n\u2502       \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 migrations/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 scripts/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 tests/\n\u2502    \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .coveragerc\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 alembic.ini\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u2514\u2500\u2500 zentra.root\n</code></pre> <p>This may look daunting at first, but don't worry, we'll break it down for you!</p>"},{"location":"api/tutorial/first-steps/#configuration-files","title":"Configuration Files","text":"<p>Tip</p> <p>Already been here and know about the files? Skip to Starting Our Project \u2728</p> <p>To start with, let's explore our main configuration files. You'll likely only touch these occassionally, specifically at the start of the project and towards the end when moving into production. </p> <p>Here's are configuration files:</p> Folder Structure<pre><code>&lt;project_name&gt;/\n...\n\u251c\u2500\u2500 .coveragerc  # (1)!\n\u251c\u2500\u2500 .env  # (2)!\n\u251c\u2500\u2500 .gitignore  # (3)!\n\u251c\u2500\u2500 alembic.ini  # (4)!\n\u251c\u2500\u2500 pyproject.toml  # (5)!\n\u251c\u2500\u2500 README.md  # (6)!\n\u2514\u2500\u2500 zentra.root  # (7)!\n</code></pre> <ol> <li>Our pytest [] coverage file, strictly used for testing purposes to identify the line coverage for our project. This is updated automatically and should never be manually edited.</li> <li> <p>Our environment variable file. A fundamental file to securing our sensitive information such as API keys and database details. </p> <p>We recommend you get familiar with this and update any information you need to. We'll talk about this in more detail shortly.</p> </li> <li> <p>A Git [] version control file used to ignore specific files and  directories from being pushed to platforms like GitHub. Feel free to explore this at your own leisure.</p> </li> <li>Our Alembic [] configuration file, used for database migration tracking. We've configured this to work with new projects automatically.</li> <li>Our Poetry [] configuration file. This handles all of our project details and Python dependencies. We'll make some changes to this shortly.</li> <li>Our main Markdown [] file for explaining more about the project. You can think of this as the face of the project. This is the first thing users will see when you publish your project to places like GitHub [] and PyPi [].</li> <li>A <code>Zentra</code> configuration file to detect the root of your directory. This is used by the CLI to allow commands to be accessed anywhere in your project.</li> </ol> <p>To keep things simple, we'll only focus on the main configuration files you need to address, but if you need more information you can check the <code>+</code> marks above. </p> <p>Most of the files are already pre-configured with your new project, but we do need to make some minor tweaks to make it unique to you!</p>"},{"location":"api/tutorial/first-steps/#poetry-configuration-pyprojecttoml","title":"Poetry Configuration (pyproject.toml)","text":"Example pyproject.toml <pre><code>[build-system]\nrequires = [\"poetry-core\"]\nbuild-backend = \"poetry.core.masonry.api\"\n\n[tool.poetry]\nname = \"app\"\nversion = \"0.1.0\"\ndescription = \"A backend for processing API data.\"\nauthors = [\"Placeholder Name &lt;placeholder@email.com&gt;\"]\nreadme = \"README.md\"\n\n[tool.poetry.scripts]\nrun-dev = \"scripts.run:development\"\nrun-prod = \"scripts.run:production\"\ndb-migrate = \"scripts.db_migrate:main\"\n\n[tool.poetry.dependencies]\npython = \"^3.12\"\nfastapi = \"^0.112\"\nsqlalchemy = \"^2.0\"\nalembic = \"^1.13\"\npydantic-settings = \"^2.4\"\npyjwt = \"^2.9\"\nbcrypt = \"^4.2\"\n\n[tool.poetry.group.dev.dependencies]\npytest = \"^8.3\"\npytest-cov = \"^5.0\"\n</code></pre> <p>Starting with the <code>pyproject.toml</code> file there is one major change you need to make - the authors. Make this bad boy unique to you \ud83e\udd29!</p> pyproject.toml<pre><code>[tool.poetry]\nname = \"app\"\nversion = \"0.1.0\"\ndescription = \"A backend for processing API data.\"\nauthors = [\"Placeholder Name &lt;placeholder@email.com&gt;\"] # (1)!\nreadme = \"README.md\"\n...\n</code></pre> <ol> <li>Update me!</li> </ol> <p>The rest of the file is pretty common with the exception of <code>tool.poetry.scripts</code> and the project <code>name</code>. </p> <p>The <code>name</code> is directly tied to the <code>app</code> directory and should only be changed when desperately needed. We use the name <code>app</code> by convention to indicate your application code. </p> <p>Warning</p> <p>Changing the <code>app</code> name may break other parts of the project, such as <code>Alembic</code> so change it at your own risk.</p> <p>The <code>poetry.scripts</code> are unique commands to your project and are connected to the <code>scripts</code> directory. They won't actually work yet until you install them (we'll get to that soon!). </p> <p>Interested in what they do? Check out the Poetry Scripts page.</p>"},{"location":"api/tutorial/first-steps/#environment-variables-env-file","title":"Environment Variables (.env file)","text":"<p>The <code>.env</code> file is an essential piece of the project for connecting the database and managing private information like API keys. </p> <p>Here's an example of what yours might look like with a project name of <code>deep_dive</code>:</p> .env<pre><code># Database details\nDB__URL=sqlite:///./dev_db.db\n# DB__URL=postgresql://user:password@postgresserver/db\n\nDB__FIRST_SUPERUSER=admin@example.com\nDB__FIRST_SUPERUSER_PASSWORD=p3qtC5sKhRHJjO3ydDVwfQ\n\n# Authentication configuration details\nAUTH__SECRET_ACCESS_KEY=c_KnbHr01TI5qjsAZoGLpeZrpdK4u5AOy7RXHFpsMeE\nAUTH__SECRET_REFRESH_KEY=M2Myg1Z2vfUNHzIBVcsKhZCcFi6n4knNLv57Gip6a3M\n\n# Project settings\n# This would be set to the production domain with an env var on deployment\nDOMAIN=localhost\n\n# Environment: local, staging, production\nENVIRONMENT=local\n\nPROJECT_NAME=deep_dive\nBACKEND_CORS_ORIGINS=\"http://localhost,http://localhost:8080\"\n\n# Emails\nEMAIL__SMTP_HOST=\nEMAIL__SMTP_USER=\nEMAIL__SMTP_PASSWORD=\nEMAIL__FROM_EMAIL=info@example.com\nEMAIL__SMTP_TLS=True\nEMAIL__SMTP_SSL=False\nEMAIL__SMTP_PORT=587\n\n# Docker\nSTACK_NAME=deep_dive-stack\nDOCKER_IMAGE_BACKEND=backend\nDOCKER_IMAGE_FRONTEND=frontend\n</code></pre> <p>The \ud83d\ude0e part about this file is that the highlighted lines are randomly generated on project creation. Zentra does all the work for you! \u2728</p> <p>Tip</p> <p>Desperately need a new <code>SECRET_KEY</code> or <code>PASSWORD</code>? Use the <code>new-key</code> CLI commmand! \ud83d\ude0f</p> <p>To start with, you won't need to change this file unless you have a specific database in mind. By default we use a SQLite [] database with SQLAlchemy [] for development.</p> <p>In fact, we encourage and recommend you start with this approach and then transition to a PostgreSQL [] database during production. It's the easiest to transition to and integrates seamlessly with our project setup.</p>"},{"location":"api/tutorial/first-steps/#tests-directory","title":"Tests Directory","text":"Test Folder<pre><code>&lt;project_name&gt;/\n...\n\u251c\u2500\u2500 tests/\n\u2502    \u251c\u2500\u2500 __init__.py\n\u2502    \u251c\u2500\u2500 conftest.py\n\u2502    \u2514\u2500\u2500 test_auth.py\n...\n</code></pre> <p>Home to your Pytest [] unit tests and other testing code. </p> <p>It already has a few files inside, one for user authentication (<code>test_auth.py</code>) and another for database (<code>conftest.py</code>) tests. These are generated automatically whenever you build a new API project to help you dive straight into your own code immediately. </p> <p>We encourage you to add to this folder when building up your application. We have a few plans to make testing easier in future versions, so stay tuned for that!</p>"},{"location":"api/tutorial/first-steps/#migrations-directory","title":"Migrations Directory","text":"Migrations Folder<pre><code>&lt;project_name&gt;/\n...\n\u251c\u2500\u2500 migrations/\n\u2502    \u251c\u2500\u2500 env.py\n\u2502    \u251c\u2500\u2500 README\n\u2502    \u2514\u2500\u2500 script.py.mako\n...\n</code></pre> <p>A place for your Alembic [] database migrations. </p> <p>We've preconfigured this directory to work out of the box with your project, but you will need to make minor additions to the <code>env.py</code> file when making new database tables.</p> <p>It's extremely easy to do, you only need to add <code>import</code> statements at the top of the file like the below:</p> migrations/env.py<pre><code>...\nfrom sqlalchemy import engine_from_config\nfrom sqlalchemy import pool\n\nfrom alembic import context\n\nfrom app.core.db import Base\nfrom app.db_models.user import DBUser, DBUserDetails\n\n# Add new imports here\n\nload_dotenv()\n...\n</code></pre> <p>This helps <code>Alembic</code> know which database tables it needs to manage. Admittedly, we sometimes forget to add this ourselves! \ud83d\ude05 So, we plan to automate this in a future version. </p>"},{"location":"api/tutorial/first-steps/#scripts-directory","title":"Scripts Directory","text":"<p>A folder dedicated to <code>poetry.scripts</code> used in the project. </p> <p>You can read more about this in the Poetry Scripts page.</p>"},{"location":"api/tutorial/first-steps/#app-directory","title":"App Directory","text":"<p>Saving the best for last, our application directory! Home to all of your API code, you'll be working in this folder constantly. From building new routes to database tables this folder really is the workhorse of the operation.</p> <p>Here's what it looks like:</p> App Directory<pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 api/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 auth/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 responses.py\n\u2502   \u2502   \u2514\u2500\u2500 schema.py\n\u2502   \u251c\u2500\u2500 core/\n\u2502   \u2502   \u2514\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 config.py\n\u2502   \u2502   \u2514\u2500\u2500 db.py\n\u2502   \u2502   \u2514\u2500\u2500 dependencies.py\n\u2502   \u2514\u2500\u2500 db_models/\n\u2502       \u2514\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 user.py\n...\n</code></pre> <p>This folder starts with four directories:</p> <ul> <li><code>api</code> - a place to store all your API routes. We'll explore this in more detail in the next chapter - Creating Routes.</li> <li><code>auth</code> - files dedicated to user authentication. We discuss more about this in the Authentication chapter.</li> <li><code>core</code> - this contains all of our configuration settings for the project. Check out the Project Settings chapter for more details.</li> <li><code>db_models</code> - our one-stop shop for our SQLAlchemy [] database models. We discuss this in more detail in the Creating Tables chapter.</li> </ul>"},{"location":"api/tutorial/first-steps/#starting-our-project","title":"Starting Our Project","text":"<p>Whew! Okay, that was a lot to digest! Now that we have installed the project and are more familiar with it, we should probably check that our project works right?</p> <ol> <li> <p>Firstly, access the project directory:</p> Using <code>zentra-sdk</code>? <p>Access the FastAPI project using this instead: <pre><code>cd backend\n</code></pre></p> <pre><code>cd &lt;project_name&gt;\n</code></pre> </li> <li> <p>Next, install the poetry scripts and extra packages:</p> <pre><code>poetry install\n</code></pre> </li> <li> <p>Test it works by running the development environment:</p> <pre><code>run-dev\n</code></pre> </li> <li> <p>Navigate to http://localhost:8080/api/docs and you should see your authentication routes already configured!</p> </li> </ol> <p></p> <p>Awesome work! \ud83d\udc4f In the next chapter we'll start building some API routes. See you there!</p>"},{"location":"api/tutorial/settings/","title":"Project Settings","text":"<p>Coming Soon</p>"},{"location":"help/","title":"Help","text":"<p>This chapter focuses on steps you can take when encountering errors when using one of <code>Zentra's</code> command-line interfaces (CLIs) or SDKs.</p> <p>We've tried to design the error messages to provide you with useful feedback so you can debug and fix most problems yourself.</p> <p>We know how frustrating errors can be and want to help you focus on programming your project with minimal interference. However, we cannot account for everything. </p> <p>If you need additional information on an error message, we recommend you refer to our Error Handling Guide first.</p> <p>If it's unable to help, we encourage you to follow our Reporting Issues Guide.</p>"},{"location":"help/errors/","title":"Errors","text":"<p>Like any program or tool, encountering errors can be very frustrating, and typically, unavoidable.</p> <p>While we've taken great care to mitigate running into errors when using <code>Zentra</code>, they can still occur. People use tools in different ways and it can be extremely difficult to interpret how someone will use the tool for their own benefit.</p> <p>Rather than blindly asking everyone to post their issues on the GitHub repo, we've curated a list of error messages that you may encounter when using the tool.</p> <p>We encourage everyone to refer to this list and use it as a guideline first, before posting an issue on GitHub.</p>"},{"location":"help/errors/#how-this-guide-works","title":"How This Guide Works","text":"<p>We've designed our error messages to be as informative as possible so that you can solve the issue yourself without any external intervention. Normally, this will suffice but there are rare circumstances where that won't be the case.</p> <p>Each error will come with a code that will help you navigate to a part of this page for details on why the error is happening and how you could potentially solve it.</p> <p>Simply use the find (<code>Ctrl + f</code> on Windows, Linux and ChromeOS, or <code>cmd + f</code> on Mac) function in your browser. Then, copy and paste the <code>Error Code: [number]</code> to find it on the page.</p> <p>If you've encountered something extremely mind boggling (trust me, you'll know ), please follow our Reporting Issues Guide.</p>"},{"location":"help/errors/#types-of-errors","title":"Types of Errors","text":"<p>Error messages are split into three main categories:</p> <ul> <li><code>common</code> - errors that can occur across all commands and packages. These range between <code>[1, 10]</code></li> <li><code>setup</code> - errors specific to the <code>init</code> command. These range between <code>[11, 20]</code>.</li> <li><code>build</code> - errors specific to the <code>generate</code> and <code>build</code> commands. These range between <code>[21, 30]</code>.</li> </ul>"},{"location":"help/errors/#1000-unknown-error","title":"1000: Unknown Error","text":"<p><code>Error Code: 1000</code></p> <p>You'll encounter this error when something happens that we haven't accounted for.</p> <p>For these types of errors, please follow our Reporting Issues Guide.</p>"},{"location":"help/errors/build/","title":"Build/Generate Errors","text":"<p>These types of errors are unique to the <code>build</code> and <code>generate</code> commands in the API and Models packages, respectively. These errors range between <code>[22, 30]</code>.</p>"},{"location":"help/errors/build/#22-build-directory-missing","title":"22: Build Directory Missing","text":"<p><code>Error Code: 22</code></p> <p>You'll encounter this error when the <code>build</code> directory is missing.</p> <p>To fix it, ...</p>"},{"location":"help/errors/common/","title":"Common Errors","text":"<p>These types of errors can commonly occur across all commands and packages and range between <code>[1, 10]</code>.</p>"},{"location":"help/errors/common/#1-config-file-missing","title":"1: Config File Missing","text":"<p><code>Error Code: 1</code></p> <p>You'll encounter this error when the <code>__init__.py</code> file is missing from the <code>zentra/models</code> directory.</p> <p>To fix it, run the <code>zentra init</code> command to create a new <code>config</code> file.</p>"},{"location":"help/errors/common/#2-config-file-empty","title":"2: Config File Empty","text":"<p><code>Error Code: 2</code></p> <p>You'll encounter this error when the <code>__init__.py</code> file in the <code>zentra/models</code> directory is empty.</p> <p>To fix it, run <code>zentra init --reset-config</code> to create a new one.</p>"},{"location":"help/errors/common/#3-zentra-directory-missing","title":"3: Zentra Directory Missing","text":"<p><code>Error Code: 3</code></p> <p>You'll encounter this error when you have the <code>Zentra</code> package installed but haven't initialised the project yet.</p> <p>To fix it, run the <code>zentra init</code> command.</p>"},{"location":"help/errors/common/#4-models-directory-missing","title":"4: Models Directory Missing","text":"<p><code>Error Code: 4</code></p> <p>You'll encounter this error when the <code>zentra/models</code> directory is missing.</p> <p>To fix it, run the <code>zentra init</code> command.</p>"},{"location":"help/errors/common/#5-no-components-found","title":"5: No Components Found","text":"<p><code>Error Code: 5</code></p> <p>You'll encounter this error when the <code>Zentra</code> app cannot find any <code>React</code> components to create.</p> <p>To fix it, open the config file at <code>zentra/models/__init__.py</code> and perform the following checks:</p> <ol> <li><code>zentra = Zentra()</code> is initialised</li> <li>You've registered some <code>components</code> or <code>pages</code> using <code>zentra.register()</code></li> </ol> <p>If you are still experiencing issues, please reset the config file with <code>zentra init --reset-config</code>.</p>"},{"location":"help/errors/common/#1000-unknown-error","title":"1000: Unknown Error","text":"<p><code>Error Code: 1000</code></p> <p>You'll encounter this error when something happens that we haven't accounted for.</p> <p>For these types of errors, please follow our Reporting Issues Guide.</p>"},{"location":"help/errors/setup/","title":"Setup Errors","text":"<p>These types of errors are unique to the <code>init</code> command but can occur across all and packages. These errors range between <code>[11, 20]</code>.</p>"},{"location":"help/errors/setup/#11-import-error","title":"11: Import Error","text":"<p><code>Error Code: 11</code></p> <p>You'll encounter this error when failing to find the <code>Zentra</code> app in <code>zentra/models/__init__.py</code>.</p> <p>To fix it, perform one of the following:</p> <ol> <li>If the file exists, initialise <code>zentra = Zentra()</code></li> <li>Reset the config file with <code>zentra init --reset-config</code></li> </ol>"},{"location":"models/","title":"Zentra Models","text":"<p>Coming Soon</p>"},{"location":"models/commands/generate/","title":"Generate","text":"Noteworthy Features <ul> <li>Manages all files in the <code>zentra/build</code> folder</li> <li>Builds, updates, and removes <code>React</code> components dynamically</li> </ul> <p>This is the main command you will run when using <code>Zentra</code>. It creates and updates your <code>React</code> components by reading the information in the <code>Zentra</code> app.</p> <pre><code>zentra-models generate\n</code></pre> <p>You can read more about it in our Basic Usage Guide.</p>"},{"location":"models/commands/init/","title":"Init","text":"Noteworthy Features <ul> <li>First use: configures the directory as a <code>Zentra</code> project</li> <li>Additional uses: adds missing configuration files to the <code>zentra</code> directory</li> </ul> <p>This command initialises the current directory as a <code>Zentra</code> project, configuring it with the specific files required for using <code>Zentra</code>.</p> <pre><code>zentra-models init &lt;project_name&gt;\n</code></pre> <p>This requires confirmation to initialise the application and is the recommended approach to running the command.</p>"},{"location":"models/commands/init/#init-optional-flags","title":"Init: Optional Flags","text":"<p>Warning</p> <p>When using <code>--reset-config</code> all its content is reset back to the default template. You will lose the existing content inside of it.</p> Flag Description <code>--force</code> removes confirmation requirement. Also, works with <code>--reset-config</code>. <code>--reset-config</code> hard resets the <code>zentra/models/__init__.py</code> file. <p>You can read more about the <code>zentra init</code> command in our Basic Usage Guide.</p>"},{"location":"models/tutorial/","title":"Tutorial - User Guide","text":"<p>Coming Soon</p>"},{"location":"sdk/","title":"Zentra SDK","text":"<p>Docs</p> <p>Code</p> <p>PyPi</p> <p>The SDK is the easiest way to get a full-stack application up and running in minutes. </p> <p>It includes the API and Models packages for the FastAPI [] backend and builds the Next.js [] frontend automatically too.</p> <p>Important</p> <p>The Zentra SDK requires you to have the Docker Engine installed to create the frontend files. Please make sure you have Docker running first before using the package.</p> <p>To get started, install the <code>zentra-sdk</code> package with Poetry [] through PIP []:</p> <pre><code>pip install zentra-sdk poetry\n</code></pre> <p>And that's it! Click the button below to move onto the User Guide to create your first project.</p>"},{"location":"sdk/commands/","title":"CLI Commands","text":"<p>This section focuses on the command line interface (CLI) commands you can use with the <code>zentra-sdk</code> package.</p> <p>Note</p> <p>In this package, all commands are prefixed with <code>zentra</code> for simplicity.</p> <p>Like the tutorial series, we've divided this section into separate pages to make things easier to navigate. You can access the commands using the navigation menu on the left or select a command from the list below.</p> <p>Help Flag</p> <p>All commands are configured with a <code>--help</code> flag that provides you with extra information about them. Simply add it to the command to read more information about it. For example:</p> <pre><code>zentra init --help\n</code></pre>"},{"location":"sdk/commands/#available-commands","title":"Available Commands","text":"<ul> <li>init</li> </ul>"},{"location":"sdk/commands/init/","title":"Init","text":"Noteworthy Features <ul> <li>First use: adds the <code>backend</code> and <code>frontend</code> files</li> <li>Additional uses: adds missing files to the directory</li> </ul> <p>This command initialises the current directory as a <code>Zentra</code> project, configuring it with a FastAPI [] backend and Next.js [] frontend.</p> <pre><code>zentra init\n</code></pre> <p>You can read more about this command in our Creating a Project Tutorial.</p>"},{"location":"sdk/tutorial/","title":"Tutorial - User Guide","text":"<p>This tutorial series shows you how to use the basics of <code>zentra-sdk</code>.</p> <p>You'll find this to be relatively short as you will mainly be working with the API and Models packages.</p> <p>When your ready, click on the button below to create your first project! \ud83e\udd29</p>"},{"location":"sdk/tutorial/create/","title":"Creating a Project","text":"<p>Using the SDK is the easiest method for getting started with a new project.</p> <p>Simply run the <code>init</code> command and you'll have a FastAPI [] backend and Next.js [] frontend in seconds! No extra parameters needed.</p> <pre><code>zentra init\n</code></pre> <p>You'll find two new shiny directories in your project folder that will look similar to this:</p> <pre><code>&lt;project_name&gt;/\n\u251c\u2500\u2500 backend/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 .env\n\u2502   \u251c\u2500\u2500 alembic.ini\n\u2502   \u251c\u2500\u2500 pyproject.toml\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 frontend/\n\u2502   \u251c\u2500\u2500 public/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u2514\u2500\u2500 ...\n\u2502   \u251c\u2500\u2500 .env.local\n\u2502   \u251c\u2500\u2500 package.json\n\u2502   \u251c\u2500\u2500 tailwind.config.js\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 env/\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 .gitignore\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"sdk/tutorial/create/#backend-directory","title":"Backend Directory","text":"Did you know? <p>We built the backend using the <code>zentra-api</code> package!  <pre><code>zentra-api init backend\n</code></pre></p> <p>Pretty cool right?! \ud83e\udd13</p> <p>The backend directory is home to our FastAPI [] files and is fully managed by the <code>zentra-api</code> package.</p> <p>You can read more about it in the API First Steps tutorial.</p>"},{"location":"sdk/tutorial/create/#frontend-directory","title":"Frontend Directory","text":"<p>The frontend directory contains our Next.js [] files and is unique to the SDK package.</p> <p>We'll read more about this in the next chapter, but for now, we should probably finish setting up the frontend!\ud83d\ude05</p>"},{"location":"sdk/tutorial/create/#starting-the-frontend","title":"Starting The Frontend","text":"<ol> <li> <p>Firstly, access the frontend directory:</p> <pre><code>cd frontend\n</code></pre> </li> <li> <p>Next, install the Node packages:</p> <pre><code>npm install\n</code></pre> </li> <li> <p>Test it works by running the development environment:</p> <pre><code>npm run dev\n</code></pre> </li> <li> <p>Navigate to http://localhost:3000 and you should see the following:</p> </li> </ol> <p></p> <p>If so, you are good to go! \ud83d\ude80</p>"},{"location":"sdk/tutorial/frontend-files/","title":"Frontend Files","text":"<p>The <code>frontend</code> directory is home to all the <code>Next.js</code> and <code>React</code> assets.</p> Frontend Folder Structure <pre><code>frontend/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 next.svg\n\u2502   \u2514\u2500\u2500 vercel.svg\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u2502   \u251c\u2500\u2500 globals.css\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx\n\u2502   \u2502   \u2514\u2500\u2500 page.tsx\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 lib/\n\u2502       \u2514\u2500\u2500 utils.ts\n\u251c\u2500\u2500 .env.local\n\u251c\u2500\u2500 .eslintrc.json\n\u251c\u2500\u2500 components.json\n\u251c\u2500\u2500 next-env.d.ts\n\u251c\u2500\u2500 next.config.mjs\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 postcss.config.mjs\n\u251c\u2500\u2500 tailwind.config.ts\n\u2514\u2500\u2500 tsconfig.json\n</code></pre>"},{"location":"sdk/tutorial/frontend-files/#configuration-files","title":"Configuration Files","text":"Root Frontend Files<pre><code>frontend/\n...\n\u251c\u2500\u2500 .env.local # (1)!\n\u251c\u2500\u2500 .eslintrc.json # (2)!\n\u251c\u2500\u2500 components.json # (3)!\n\u251c\u2500\u2500 next.config.mjs # (4)!\n\u251c\u2500\u2500 next-env.d.ts # (5)!\n\u251c\u2500\u2500 package.json # (6)!\n\u251c\u2500\u2500 postcss.config.mjs # (7)!\n\u251c\u2500\u2500 tailwind.config.ts # (8)!\n\u2514\u2500\u2500 tsconfig.json # (9)!\n</code></pre> <ol> <li>An environment variable file for storing API keys and confidential information unique to the frontend.</li> <li>The config file for Eslint []. This is automatically generated by <code>Next.js</code> and should never be manual edited.</li> <li>The config file for Shadcn/ui  []. We recommend changing the <code>style</code> and <code>baseColor</code> in this file to your preference.</li> <li>The config file for Next.js []. We'll discuss this in more detail shortly.</li> <li>A TypeScript [] declaration file for Next.js []. This file is automatically generated and should never be manually modified.</li> <li>The package management file for Node []. It contains a list of all the projects <code>dependencies</code> and commands that can be run. You may occassionally visit this file.</li> <li>The config file for Postcss []. This is installed automatically with Tailwind CSS [].</li> <li>The config file for Tailwind CSS []. You'll likely visit this file occassionally for adding custom theme styles.</li> <li>The config file for TypeScript []. It is automatically created with Next.js [] and does not need to be manually edited.</li> </ol> <p>At the root level, we have numerous <code>configuration</code> files, you can read more about each one using the <code>+</code> icons above.</p>"},{"location":"sdk/tutorial/frontend-files/#environment-file-envlocal","title":"Environment File (.env.local)","text":"<p>The environment file is configured to help connect the backend and frontend together. It only contains a single URL that can be easily changed when moving to production.</p> <p>Here's what the file looks like:</p> .env.local<pre><code># The URL to connect FastAPI and NextJS together - used in `next.config.mjs`\nBACKEND_CONNECTION_URL=http://localhost:8080/\n</code></pre> <p>As long as there is a URL provided to connect the backend, this file can be edited freely. You'll often need to use it when working with API keys from packages like <code>Clerk</code> and <code>Stripe</code>.</p>"},{"location":"sdk/tutorial/frontend-files/#next-configuration-file-nextconfigmjs","title":"Next Configuration File (next.config.mjs)","text":"<p>We've preconfigured this config file to directly integrate with the FastAPI backend using the <code>BACKEND_CONNECTION_URL</code> in the <code>.env.local</code> environment file.</p> <p>This allows you to use the same URL path that hosts your frontend with your <code>api</code> paths to access your backend routes.</p> <p>For example, if you have your was frontend hosted on <code>https://awesomeposts.com/</code> and your backend on <code>https://newapi.com/</code> these access the same API routes:</p> <ul> <li><code>https://awesomeposts.com/api/posts</code> = <code>https://newapi.com/api/posts</code></li> </ul> <p>This makes frontend development a little bit easier and abstracts your API away from your users.</p> <p>For reference, here's what the config file looks like:</p> frontend/next.config.mjs<pre><code>/** @type {import('next').NextConfig} */\n\nconst apiUrl = process.env.BACKEND_CONNECTION_URL;\n\nconst nextConfig = {\n  images: {\n    remotePatterns: [\n      {\n        protocol: \"https\",\n        hostname: apiUrl,\n        pathname: `/api/*`,\n      },\n    ],\n  },\n  rewrites: async () =&gt; {\n    return [\n      {\n        source: \"/api/:path*\",\n        destination: `${apiUrl}/api/:path*`,\n      },\n      {\n        source: \"/docs\",\n        destination: `${apiUrl}/docs`,\n      },\n      {\n        source: \"/openapi.json\",\n        destination: `${apiUrl}/openapi.json`,\n      },\n    ];\n  },\n};\n\nexport default nextConfig;\n</code></pre> <p>Unless you have something specific in mind, you don't need to configure this file any further.</p>"},{"location":"sdk/tutorial/frontend-files/#public-directory","title":"Public Directory","text":"frontend/public/<pre><code>frontend/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 next.svg\n\u2502   \u2514\u2500\u2500 vercel.svg\n...\n</code></pre> <p>This directory is a place to store static files, such as images. You can then reference these files from the base URL (<code>/</code>). You can read more about it in the Next.js [] documentation.</p> <p>On project creation, this directory contains the basic files generated by Next.js [].</p>"},{"location":"sdk/tutorial/frontend-files/#source-directory","title":"Source Directory","text":"frontend/src/<pre><code>frontend/\n...\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 app/\n\u2502   \u2502   \u251c\u2500\u2500 favicon.ico\n\u2502   \u2502   \u251c\u2500\u2500 globals.css\n\u2502   \u2502   \u251c\u2500\u2500 layout.tsx\n\u2502   \u2502   \u2514\u2500\u2500 page.tsx\n\u2502   \u251c\u2500\u2500 components/\n\u2502   \u2514\u2500\u2500 lib/\n\u2502       \u2514\u2500\u2500 utils.ts\n...\n</code></pre> <p>The <code>src</code> directory is the main directory you will be working with. This is the application code directory for the frontend!</p> <p>It uses the Next.js App Router [] layout, and to keep things simple and fully customisable, the files are identical to a freshly started Next.js project using the <code>npx create-next-app@latest</code> command.</p> <p>In it, you'll find 3 directories: <code>app</code>, <code>components</code> and <code>lib</code>. Let's take a closer look at them!</p>"},{"location":"sdk/tutorial/frontend-files/#app","title":"App","text":"<p>The <code>app</code> directory handles the functionality for Next.js Routing [].</p> <p>It's a fast and simple way to build pages with ease while maintaining a well structured project.</p> <p>it contains <code>four</code> files:</p> <ul> <li><code>favicon.ico</code> - the favicon icon for the website</li> <li><code>globals.css</code> - the global CSS file applied to the whole project</li> <li><code>layout.tsx</code> - the global layout of the pages used in the project</li> <li><code>page.tsx</code> - the root/home page for the project (<code>/</code>)</li> </ul> <p>You'll primarily focus on editing the <code>layout.tsx</code> and <code>page.tsx</code> files in this directory. We also encourage you to replace the <code>favicon.ico</code> with your own to help make the project unique to you!</p> <p><code>globals.css</code> is already configured with <code>Tailwind CSS</code>. If you need to use CSS outside of the Tailwind's styles, we recommend using CSS Modules [].</p>"},{"location":"sdk/tutorial/frontend-files/#components","title":"Components","text":"<p>The <code>components</code> directory houses all your global reusable <code>React</code> components that are shared across the project.</p> <p>For example, when you add a Shadcn/ui [] component using their CLI, they can be found here inside a <code>ui</code> directory.</p>"},{"location":"sdk/tutorial/frontend-files/#lib","title":"Lib","text":"<p>The <code>lib</code> directory contains global application-specific files. These could include <code>utility</code> functions, <code>constants</code>, facades and more.</p> <p>This comes preconfigured with a <code>utils.ts</code> file with a single function. Here's what it looks like:</p> lib/utils.ts<pre><code>import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n</code></pre> <p>The <code>cn</code> function is an extremely useful utility method for handling Tailwind CSS [] classing and compressing them into a single string.</p> <p>We use this function regularly and it's been an absolute lifesafer when styling our components. ByteGrad [] has an excellent video about this on YouTube.</p> <p>We plan to make some additional changes to this layout in the future, such as adding <code>types</code>, <code>layouts</code> and <code>constants</code> directories to help organise your frontend files.</p>"},{"location":"starting/","title":"Getting Started","text":"<p>Zentra is a powerful tool that can help speed up your workflow and make development a breeze. Using it's CLI, you can quickly put together a brand new project in minutes and expand on it with minimal effort.</p>"},{"location":"starting/#whats-included","title":"What's Included?","text":"<p>Zentra SDK is divided into two packages:</p> <ul> <li>API - an SDK and CLI tool for building FastAPI [] applications</li> <li>Models - a Python based component library, turning Pydantic [] models into React components</li> </ul> <p>Each package works independently so you can maximise their benefits with ease.</p> <p>Perhaps you only want to build a FastAPI project, or simply want to build React components using Python - the choice is yours!</p>"},{"location":"starting/#complete-the-basics","title":"Complete The Basics","text":"<ul> <li> <p> Installation</p> <p>Choose the packages to install.</p> <p> Start Installing</p> </li> </ul>"},{"location":"starting/#start-using-a-package","title":"Start Using a Package","text":"<ul> <li> <p> Zentra SDK</p> <p>Learn how to use the full-suite at once.</p> <p> Start learning</p> </li> </ul> <ul> <li> <p> Zentra API</p> <p>Learn how to build FastAPI's apps with ease.</p> <p> Start learning</p> </li> <li> <p> Zentra Models</p> <p>Learn how to build React components faster using Pydantic models.</p> <p> Start learning</p> </li> </ul>"},{"location":"starting/install/","title":"Installation","text":"<p>Warning</p> <p>Zentra should always be installed in a dedicated virtual environment to isolate it from the rest of your system. </p> Unsure How? Here's an Example! <ol> <li> <p>Create a new Python environment: <pre><code>python -m venv env\n</code></pre></p> </li> <li> <p>Access it (Python Docs []):</p> WindowsLinux/MacOS <pre><code>.\\env\\Scripts\\activate\n</code></pre> <pre><code>source env/bin/activate\n</code></pre> </li> </ol> <p>Depending on your use case, you can install packages separately or download the full-suite in one command. Here's a quick comparsion between the options:</p> <ul> <li>The Full Suite - includes the API and Models packages for the FastAPI [] backend and builds the Next.js [] frontend too.</li> <li>API Only - includes the API package for building FastAPI [] backends.</li> <li>Models Only - includes the models package for building React components using Python.</li> </ul>"},{"location":"starting/install/#system-requirements","title":"System Requirements","text":"<p>All Zentra packages require Python 3.12+ [] and Poetry [] for package management. It is multi-platform and aims to be accessible across Linux, macOS and Windows.</p>"},{"location":"starting/install/#select-a-package","title":"Select a Package","text":"<ul> <li> <p> Zentra SDK</p> <p>Install the complete suite in a flash.</p> <p> Install the SDK</p> </li> </ul> <ul> <li> <p> Zentra API</p> <p>Only install the API package.</p> <p> Install the API</p> </li> <li> <p> Zentra Models</p> <p>Only install the Models package.</p> <p> Install the Models</p> </li> </ul>"},{"location":"starting/license/","title":"License","text":"<p>Zentra packages (SDK, API, and Models) are licensed under the MIT license. The MIT license is a permissive license that allows commercial use, redistribution, and everything else as long as the original authors are credited in source files.</p> <p>The MIT license is the most popular license among all Open Source projects.</p>"},{"location":"starting/license/#mit-license","title":"MIT License","text":"<p>The MIT License gives you the freedom to work with the code with minimal restrictions. When using a Zentra package, make sure to include the copyright notice and avoid future liability claims.</p> <p>Its appeal lies in its simplicity and clear terms, making it a go-to for projects of any scale. Its popularity stems from its simplicity, clarity, and development-friendly terms, making it suitable for all types of projects.</p>"},{"location":"starting/license/#advantages","title":"Advantages","text":"<p>The MIT License is favored for its balance between freedom and protection, appealing to those who find GNU/GPL licenses too restrictive or advocate for privatized software. Its broad wording supports both open community development and the use of components in proprietary software.</p> <p>Here\u2019s what this means for you:</p> <ul> <li>Freedom from vendor lock-in: Thanks to Open Source principles, you can use the Zentra packages without any strings attached. Customize or integrate it into your projects without worrying about restrictions. Your projects belong to you, and you are free to change the software at any time.</li> </ul>"},{"location":"starting/stack/","title":"Package Homage","text":"<p>Each Zentra package comes packed with a variety of packages that have been fundamental in its creation. </p> <p>This page acts as a homage to show our  and appreciation for the libraries that have helped make its packages possible.</p>"},{"location":"starting/stack/#backend","title":"Backend","text":"<ul> <li> FastAPI for API routing</li> <li> Pydantic for data validation</li> <li> SQLAlchemy our database ORM</li> <li> SQLite for our development database</li> <li> Poetry for package management</li> <li> Pytest for unit testing</li> </ul>"},{"location":"starting/stack/#frontend","title":"Frontend","text":"<ul> <li> Next.js our React framework</li> <li> Tailwind CSS for utility styling</li> <li> TypeScript for data type validation</li> <li> Lucide React for SVG icons</li> <li> Shadcn/ui our component library</li> </ul>"}]}